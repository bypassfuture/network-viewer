<!DOCTYPE html><html>
<head>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800' rel='stylesheet' type='text/css'>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<link href="mainstylesheet.css" type="text/css" rel="stylesheet" />

	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="d3.v3.min.js"></script>
	<script type="text/javascript" src="sha1.js"></script>
	
	<script type="text/javascript" src="selectbox/jquery.selectbox-0.2.min.js"></script>
	<link href="selectbox/jquery.selectbox.css" type="text/css" rel="stylesheet" />

	<script type="text/javascript" src="jscrollpane/jquery.mousewheel.js"></script>
	<script type="text/javascript" src="jscrollpane/jquery.jscrollpane.js"></script>
	<script src="jquery.inview.js"></script>
	
	<link type="text/css" href="jscrollpane/jquery.jscrollpane.css" rel="stylesheet" media="all" />

	<title>Rippleå®æ¶ç½ç»äº¤ææ¥è¯¢</title>
</head>

<body>
<div class="light heading darkgray">Rippleå®æ¶ç½ç»äº¤ææ¥è¯¢</div>


<!-- BEGIN VISUALIZATION DIV -->
<div id="visualization" style="position:relative; margin-left: auto; margin-right: auto;" class="fullwidth">
<div class="light midsize mediumgray" style="width: 100%;
    height: 100%;
    position: absolute;
    top: -72px;
	left:35px;">
æ»ç»ç¹æ°: <span id="ledgernumber"></span><br/>
rippleæ»æ°: <span id="totalripples"></span><br/></div>
<!-- top bar -->
<input id="focus" class="light midsize rounded topbar" style="left:35px; padding:0 10px; width:295px; height:42px;" type="text"/>
<input id="searchButton" class="topbar" style="left:360px; width:50px; height:50px;" type="button" value="æ¥è¯¢" onClick="changeMode('individual'); refocus($('#focus').val().replace(/\s+/g, ''),true);"/>
<div class="topbar" style="left:684px; height:42px; width:230px; outline:none;">
	<select id="currency" onchange="changeCurrency(this.value);">
		<option value="XRP">è´§å¸éæ©</option>
		<option value="USD">ç¾å</option>
		<option value="EUR">æ¬§å</option>
		<option value="JPY">æ¥å</option>
		<option value="BTC">æ¯ç¹å¸</option>
		<option value="___">å¶å®</option>
	</select>
	<input type="text" id="otherCurrency" value="other" class=" sbSelector sbHolder" onfocus="focusOtherCurrency(this);" onblur="blurOtherCurrency(this);" />
</div>

<div style="position:absolute; left:35px; top:80px; opacity:.8;">
<input style="width:25px; height:25px; font-size:12pt;" type="button" id="zoomInButton" value="+" onclick="zoomIn();" disabled="disabled"/><br/>
<input style="width:25px; height:25px; font-size:12pt;" type="button" value="&ndash;" onclick="zoomOut();"/>
</div>

<div id="loading" class="light large" style="color:#aaa; position:absolute; left:390px; top:100px; line-height:50px;">
	<img src="throbber4.gif" style="vertical-align: middle;"/>
	æ­£å¨å è½½æ°æ®...
</div>


<!-- begin information below -->
<div id="information" style="opacity:0.8; background-color:#fff; position:absolute; top:704px; left:1.3px; width:934px; height:401px; border-top: 1px solid #c8c8c8;">

<div class="tab midsize mediumgray unselectedTab" style="margin-top:-36px; margin-left:140px;" onclick="changeMode('feed');" id="feedTab">Rippleç½ç»å¹¿æ­</div>
<div id="individualTab" class="tab midsize mediumgray selectedTab" style="margin-top:-35px; margin-left:-1.25px;" onclick="changeMode('individual',senderAddress);">é±åè¯¦æ</div>


<div id="focalAddress" class="light mediumgray large" style="margin-bottom:13px; margin-top:13px; padding-left:20px; float:left;">&nbsp;</div>


<div class="clearboth"></div>


	
<div class="fullwidth topbordered horizontalrule"></div>
<div class="light midsize mediumgray" id="leftHeading" style="border: none; float:left; padding-left:20px;">æ»åºå¡å¹³è¡¡</div>
<div class="light midsize mediumgray" id="rightHeading" style="width:44%; border:none; float:right;">åå²äº¤æè®°å½</div>
<div class="clearboth"></div>
<div class="fullwidth bottombordered horizontalrule"></div>



<!-- the table on the left -->
<div class="bottomlist rightbordered" style="width:490px; float:left;">

<div class="scroll-pane" id="transactionInformationContainer" style="z-index:1; width:935px; height:288px; position:absolute; background-color:#fff; display:none;">
	<div style="width:935px; overflow-x:hidden;">
		<div id="transactionInformation" class="light midsize mediumgray" style="width:925px; padding:20px; display:none;"></div>
		<div id="transactionFeed" class="light midsize mediumgray" style="width:925px; padding:20px; display:none;">
			<table id="transactionFeedTable"></table>	
		</div>
	</div>
</div>
<div class="scroll-pane" style="height:288px; margin-left:10px;">
	<table style="width:465px; margin-top:4px;" class="outertable" id="balanceTable"></table>
</div></div>


<!-- the table on the right -->
<div class="bottomlist" style="width:435px; margin-left:500px;">
<div class="scroll-pane" style="height:288px;width:400px; ">
<table class="outertable" id="transactionTable"></table></div></div>

<div class="clearboth"></div>

</div><!-- end information at the bottom -->



</div><!-- END VISUALIZATION DIV -->




<!-- Javascript for the visualization, using the D3 library -->
<script type="text/javascript">


// WEBSOCKET OPTIONS
var Options = {
	server: {
		"websocket_ip" : "s1.ripple.com",
		"websocket_port" : 443,
		"websocket_ssl" : true
	}
};



// CONSTANTS
var RECURSION_DEPTH = 1;
var REFERENCE_NODE = 'r3kmLJN5D28dHuH8vZNUZpMC43pEHpaocV';
var HALO_MARGIN = 6;
var COLOR_TABLE = {
//currency  |  center  |   rim  |
	"__Z": [["#dfe0e1","#999999"], //degree 0
/*GRAY*/	["#ebecec","#aaa9a9"], //degree 1
			["#ededee","#bcbbbb"], //etc.
			["#f3f4f4","#d0cece"],
			["#fdfdfe","#e5e4e3"]],
			
	"__N": [["#f05656","#ee2d2c"],
/*RED*/		["#f37a6f","#f16249"],
			["#f6998b","#f5886d"],
			["#fab9ac","#f9ad95"],
			["#fddad1","#fcd4c4"]],
			
	"BTC": [["#e19e41","#b76f2f"],
/*ORANGE*/	["#e5af65","#c38a57"],
			["#e9c189","#d0a57e"],
			["#edd2ad","#dcbfa6"],
			["#f1e4d1","#e9dacd"]],
			
	"JPY": [["#fcf5a1","#fedb3d"],
/*YELLOW*/	["#fdf7b4","#ffe069"],
			["#fdf7c4","#ffe68d"],
			["#fefad8","#ffed83"],
			["#fffcea","#fff5d6"]],
			
	"USD": [["#99cc66","#669940"],
/*LIME*/	["#acd585","#82a85d"],
			["#c0dea1","#9eb880"],
			["#d4e8be","#bbcba4"],
			["#e8f2dd","#dae1cd"]],
			
	"AUD": [["#8dc198","#609869"],
/*GREEN*/	["#a2cbab","#7eab85"],
			["#b7d6bd","#9cbda1"],
			["#cbe0d0","#b9d0bd"],
			["#e0ebe2","#d7e2d9"]],
			
	"XRP": [["#55a7cc","#346aa9"],
/*BLUE*/	["#83b8d6","#5083b9"],
			["#a7cae1","#7ba1cb"],
			["#d0e1ed","#a3c2dd"],
			["#f2f6fa","#cee8f1"]],
			
	"___": [["#6566ae","#363795"], //I.e., any other currency.
/*INDIGO*/	["#7e7cbb","#5855a5"],
			["#9896c9","#7a74b6"],
			["#b6b4da","#9e99cb"],
			["#d7d6eb","#c9c6e3"]],
			
	"CAD": [["#8e68ad","#673695"],
/*VIOLET*/	["#9f80ba","#7d58a5"],
			["#8e68ad","#673695"],
			["#c8b8da","#b29ecc"],
			["#e0d8eb","#d4cae4"]],
			
	"EUR": [["#b76e99","#863d66"],
/*PINK*/	["#c389ab","#9c6283"],
			["#d0a4be","#b2879f"],
			["#dcbfd0","#c9abbc"],
			["#d9dae3","#dfd0d8"]]};
var HIGH_SATURATION_COLORS = {
	"__N": "#f00", //RED	
	"BTC": "#fa0", //ORANGE
	"JPY": "#af0", //YELLOW
	"USD": "#0f0", //LIME
	"AUD": "#0fa", //GREEN
	"XRP": "#0af", //BLUE
	"___": "#00f", //INDIGO
	"CAD": "#a0f", //VIOLET
	"EUR": "#f0a"  //PINK
};
var HEX_TO_PERCENT = {"0":0,"a":0.67,"f":1};


// WEBSOCKET SETUP	

/*
function getQueryVariable(variable) {
    var query = window.location.search.substring(1);
    var vars = query.split('&');
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
        }
    }
    return ""
}
*/


var param = window.location.hash.replace(/\W/g, '');

//var transaction_id = getQueryVariable("tx_id").replace(/\W/g, '');
//var viewingTransaction = (transaction_id != "");

var alreadyFailed = false;
var focalNode;
var transaction_id;
var viewingTransaction = false;

var changingFocus = false;

if (param == "") {
	focalNode = REFERENCE_NODE;
} else if (param.charAt(0) == "r" ) {
	focalNode = param;
} else if ("0123456789ABCDEF".indexOf(param.charAt(0)) != -1) {
	transaction_id = param;
} else if (param.charAt(0) == "u" && Sha1.hash(param) == "7d0b25cc0abdcc216e9f26b078c0cb5c9032ed8c") {
	//Easter egg!
	RECURSION_DEPTH = 999999999;
	focalNode = REFERENCE_NODE;
} else {
	focalNode = REFERENCE_NODE;
}


var lastFocalNode = REFERENCE_NODE;
var currentCurrency = "XRP";
var currentLedger = {seqNum:211147};
var w = 935;  //Width
var h = 1085; //Height
var hh = 710; //Height above the bottom bar

var nodes = [ {x:w/2, y:hh/2, account:{Account:focalNode, Balance:0}, trustLines:[], balances:{} }];
var le_links = [];
var nodeMap = {};
nodeMap[focalNode] = 0;
var degreeMap = {};
degreeMap[focalNode] = 0;

var server = {};
server.socket = null; 	
var str;
if (Options.server.websocket_ssl) {
	str= "wss://" + Options.server.websocket_ip + ":";
} else {
	str= "ws://" + Options.server.websocket_ip + ":";
}
str += Options.server.websocket_port;
str += "/";

server.socket = new WebSocket(str);
var expandedNodes = {};
var provisionallyExpandedNodes = {};

server.socket.onopen = function() { //Set up the connection and subscribe to the appropriate streams.
	command = '{"command":"subscribe", "streams" : [ "transactions" ]}';
	server.socket.send(command);
	command = '{"command":"ledger", "ledger_selector":"current"}';
	server.socket.send(command);
	if (transaction_id && transaction_id!="") {
		nodeMap = {};
		degreeMap = {};
		nodes = [];
		command= '{"command":"tx", "transaction":"'+transaction_id+'"}';
		server.socket.send(command);
	} else {
		lastFocalNode = REFERENCE_NODE;
		expandNode(focalNode);
		addNodes(0);
	}
};
var txx;
server.socket.onmessage = function(msg) { //Process a message received from Ripple.
	var obj = jQuery.parseJSON(msg.data);
	if (obj && obj.result && obj.result.lines) {
		addConnections(obj.result.account, obj.result.lines);
	} else if(obj.transaction) {
		console.log("è·å¾äº¤ææ°æ®!");
		$("#transactionFeedTable").prepend(renderTransaction(obj.transaction));
		if (obj.transaction.TransactionType == "Payment") {
			animateTransaction(obj.transaction);
		}
	} else if (obj && obj.result && obj.result.closed) {
		currentLedger = obj.result.closed.ledger;
		if (!viewingTransaction) {
			serverGetInfo(focalNode);
		}
		$("#ledgernumber").text(commas(parseInt(currentLedger.seqNum)));
		$("#totalripples").text(commas(parseInt(currentLedger.totalCoins)/1000000));
	} else if (obj && obj.result && obj.result.account_data) {
		if ($.isEmptyObject(obj.result.account_data)) {
			alert("This address is not valid!");
			console.log(obj);
			refocus(lastFocalNode,true);
		} else {
			var n = nodes[nodeMap[obj.result.account_data.Account]];
			n.account = obj.result.account_data;
			if (currentCurrency == "XRP") { // Change the size of the circles, and recalculate the arrows.
				updated = svg.select("g#nodeGroup").select("circle#_"+obj.result.account_data.Account);
				updated.attr("r", nodeRadius(n));
				svg.select("g#haloGroup").select("circle#halo_"+obj.result.account_data.Account).attr("r", HALO_MARGIN+nodeRadius(n));;
			}
			if (obj.result.account_data.Account == focalNode) {
				//Update the XRP listing on the table below. (But don't rewrite the whole table)
				$("#xrpBalance").text(commas(n.account.Balance/1000000));
			}
		}
	} else if (obj && obj.result && obj.result.transactions) {
		var n = nodes[nodeMap[obj.result.account]];
		//console.log("GOT YOUR TRANSACTIONS!", obj.result);
		if (n.transactions) {
			if (obj.result.offset == n.transactions.length) {
				n.transactions.push.apply(n.transactions, obj.result.transactions);
				//n.transactions.extend(obj.result.transactions); //OR WHATEVER THIS IS.
			} else {
				console.log("THIS SHOULD NOT HAPPEN!");
			}
		} else {
			n.transactions = obj.result.transactions;
		}
		if (obj.result.count) {
			n.transactionCount = obj.result.count;
		}
		if (obj.result.account == focalNode) {
			updateTransactions(focalNode, true); //appending=true
		}
	} else if (obj && obj.result && obj.result.TransactionType) {
		console.log("got info on transaction.");
		console.log(obj);
		txx = obj.result;
		changeMode("transaction", txx);
	} else if (obj.error) {
		if (obj.error=="noNetwork") {
			if (!alreadyFailed) {
				alert("Could not connect to Ripple network - please try again later.");
				alreadyFailed = true;
			}
		} else if (obj.error=="txnNotFound") {	
			$("#loading").text("Transaction not found!").css("color","#a00");
		} else if (obj.error=="actNotFound" || obj.error=="actMalformed") {	
			$("#loading").text("Account not found!").css("color","#a00");
		} else {
			console.log("An unknown error occured.");
			console.log(obj);
		}
	} else {
		console.log("Could not interpret message.");
		console.log(obj);
	}
};

server.socket.onclose = function() {
	console.log("disconnected from websocket");
} 




// MODE CHANGING

var mode = "individual";
var senderAddress;

function changeMode(newMode, data) {
	if (mode != newMode) {
		if (mode=="individual") {
			exitIndividualMode();
		} else if (mode=="transaction") {
			exitTransactionMode();
		} else if (mode=="feed") {
			exitFeedMode();
		}
		if (newMode=="individual") {
			enterIndividualMode(data);
		} else if (newMode=="transaction") {
			enterTransactionMode(data);
		} else if (newMode=="feed") {
			enterFeedMode();
		}
		mode = newMode;
	}
}

function enterIndividualMode(data) {
	if (mode != "individual") {
		$("#leftHeading").text("æ»åºå¡å¹³è¡¡è¡¨");
		$("#rightHeading").text("åå²äº¤æç¶åµ");
		$("#focalAddress").css("visibility","visible");
		$("#balanceTable").css("visibility","visible");
		$("#transactionTable").css("visibility","visible");
		$("#transactionInformationContainer").css("display","none"); //This is here because it is used by both feed and transaction modes.
		$("#feedTab").addClass("unselectedTab").removeClass("selectedTab").css("visibility","visible");
		$("#individualTab").removeClass("unselectedTab").addClass("selectedTab").css("visibility","visible");
		if (data) {
			expandNode(data);
			senderAddress = false;
		}
		mode = "individual";
	}
}
function exitIndividualMode() {
	if (mode == "individual") {
		$("#rightHeading").text("");
		$("#focalAddress").css("visibility","hidden");
		$("#balanceTable").css("visibility","hidden");
		$("#transactionTable").css("visibility","hidden");
		$("#transactionInformationContainer").css("display","inherit");
	}
}

function enterFeedMode() {
	if (mode != "feed") {
		$("#feedTab").removeClass("unselectedTab").addClass("selectedTab");
		$("#individualTab").addClass("unselectedTab").removeClass("selectedTab");
		$("#transactionFeed").css("display","inherit");
		$("#leftHeading").text("å®æ¶äº¤æç¶åµ");
		mode = "feed";
	}
}
function exitFeedMode() {
	if (mode == "feed") {
		$("#transactionFeed").css("display","none");
	}
}

function enterTransactionMode(tx) {
	if (mode != "transaction") {
		eraseGraph();
		txx = tx;
		$("#transactionInformation").html(txDescription(tx));
		var currency;
		if (tx.Amount.currency) {
			currency = tx.Amount.currency;
		} else {
			currency = "XRP";
		}
		var option = $("select#currency").find("option[value="+currency+"]");
		if (option.html()) {
			$("select#currency").selectbox("change", currency, option.html());
		} else {
			$("select#currency").selectbox("change", "___", "SSGSGS");
			$("#otherCurrency").attr("value",currency);
			$('#otherCurrency').css('font-style','inherit').css('color','inherit');
			changeCurrency("___");
		}
		senderAddress = tx.Account;
		var k = 0;
		nodes.push({x:w*Math.random(), y:hh*Math.random(), account:{Account:tx.Account, Balance:0}, trustLines:[], balances:{} }); //
		nodeMap[nodes[k].account.Account] = k;
		degreeMap[nodes[k].account.Account] = 0;
		k++;
		if (tx.Paths) {
			for (var i=0; i<tx.Paths.length; i++) {
				for (var j=0; j<tx.Paths[i].length; j++) {
					if ("undefined" == typeof nodeMap[tx.Paths[i][j].account]) {
						if (tx.Paths[i][j].account) {
							nodes.push({x:w*Math.random(), y:hh*Math.random(), account:{Account:tx.Paths[i][j].account, Balance:0}, trustLines:[], balances:{} });
							nodeMap[nodes[k].account.Account] = k;
							degreeMap[nodes[k].account.Account] = 1;
							k++;
						} else {
							console.log("Rippleè·¯å¾æ²¡æååº.");
						}
					} else {
						console.log("èç¹å·²ç»è¢«æ·»å è³ç½ç».");
					}
				}
			}
		}
		nodes.push({x:w*Math.random(), y:hh*Math.random(), account:{Account:tx.Destination, Balance:0}, trustLines:[], balances:{} });

		nodeMap[nodes[k].account.Account] = k;
		degreeMap[nodes[k].account.Account] = 0;
		k++;
		
		addNodes(1);
		for (var i=0; i<nodes.length; i++) {
			serverGetInfo(nodes[i].account.Account);
			serverGetLines(nodes[i].account.Account);
		}
		setTimeout(function(){animateTransaction(tx);}, 2000);
		$("#leftHeading").html("Transaction information <input type='button' style='position:absolute; top:56px; left:200px;' onclick='animateTransaction(txx);' value='Animate'/>");
		$("#feedTab").addClass("unselectedTab").removeClass("selectedTab");
		$("#individualTab").addClass("unselectedTab").removeClass("selectedTab");
		$("#transactionInformation").css("display","inherit");
		mode = "transaction";
	}
}
function exitTransactionMode() {
	if (mode == "transaction") {
		$("#transactionInformation").css("display","none");
	}
}

function eraseGraph() {
	zoomLevel = 1;
	translationX = 0;
	translationY = 0;
	panAndZoom();
	$("#zoomInButton").attr("disabled","disabled");

	panOffset = [lastD3ZoomEvent.translate[0], lastD3ZoomEvent.translate[1]];
	svg.select("g#nodeGroup").selectAll("circle.node").data([]).exit().remove();
	svg.select("g#linkGroup").selectAll("line")       .data([]).exit().remove();
	svg.select("g#haloGroup").selectAll("circle.halo").data([]).exit().remove();
	svg.select("g#arrowheadGroup").selectAll("path.arrowhead").data([]).exit().remove();
	
	nodes = [];
	le_links = [];
	nodeMap = {};
	expandedNodes = {};
	provisionallyExpandedNodes = {};
	animatorLinks = [];
	$("#loading").css("display","block").css("color","#aaa");;
	$("#loading").html('<img src="throbber4.gif" style="vertical-align: middle;" /> Loading...');
}


// DATA-TO-HTML FUNCTIONS
function renderTransaction(tx) {
	var transactionType;
	var from = tx.Account;
	var to = null;
	var amount = null;
	var currency = null;
	var secondAmount = null;
	var secondCurrency = null;
	if (tx.TransactionType == "Payment") {
		amount = tx.Amount;
		transactionType = "send";
		to = tx.Destination;
	} else if (tx.TransactionType == "TrustSet") {
		amount = tx.LimitAmount;
		transactionType = "trustout";
		to = tx.LimitAmount.issuer;
	} else if (tx.TransactionType == "OfferCreate") {
		transactionType = "offerout";
		amount = tx.TakerGets;
		secondAmount = tx.TakerPays;
	} else if (tx.TransactionType == "OfferCancel") {
		transactionType = "canceloffer";
	} else {return;}
	if (amount) {
		if (amount.currency) {
			currency = amount.currency;
			amount = amount.value;
		} else {
			currency = "XRP";
			amount = amount/1000000;
		}
	}
	if (secondAmount) {
		if (secondAmount.currency) {
			secondCurrency = secondAmount.currency;
			secondAmount = secondAmount.value;
		} else {
			secondCurrency = "XRP";
			secondAmount = secondAmount/1000000;
		}
	}
	transactionMap[tx.hash] = tx;
	return ('<tr>'+
		'<td style="width:80px;">'+absoluteTime(tx.date)+'</td>'+
		'<td style="width:1px;">'+clickableAccountSpan(from)+'</td>'+
		'<td style="width:40px;"><div '+(transactionType=='send'?'onclick="showTransactionWithHash(\''+tx.hash+'\')"':'')+' class="'+transactionType+' icon" title="'+txAltText[transactionType]+'">&nbsp;</div></td>'+
		( to||secondAmount ?
			'<td style="width:1px;"><span class="bold amount small">'+commas(amount)+'</span>&nbsp;<span class="light small darkgray">'+currency+'</span></td>'+
			'<td style="text-align:center; width:20px;"><i class="light small darkgray">'+
			( to ?
				'å°</i></td>'+
				'<td style="width:1px;">'+clickableAccountSpan(to)+'</td>'
				:
				'for</i></td>'+
				'<td style="width:1px;"><span class="bold amount small">'+commas(secondAmount)+'</span>&nbsp;<span class="light small darkgray">'+secondCurrency+'</span></td>'
			)
			:
			'<td colspan=3></td>'
		)+
		'</tr>');
}

function clickableAccountSpan(address) {
	var o = "<span class='light address' style='cursor:pointer;' "+
		"onmouseover='lightenAddress(\""+address+"\");' "+
		"onmouseout='darkenAddress(\""+address+"\");' "+
		"onclick='expandNode(\""+address+"\");'>"+
		address+"</span>";
	return o;
}

function txDescription(result) {
	var output = "<b>Amount:</b> <span class='amount'>"+
		(result.Amount.currency ? commas(result.Amount.value)+" "+result.Amount.currency : commas(result.Amount/1000000)+" XRP")+
		"</span><br/><b>Path:</b><ul>"+
		(function(){
			var output = "";
			if (result.Paths) {
				for (var i=0; i<result.Paths.length; i++) {
					var listItem = "<li>"+clickableAccountSpan(result.Account) + " &rarr; ";
					for (var j=0; j<result.Paths[i].length; j++) {
						if (result.Paths[i][j].account) {
							listItem += clickableAccountSpan(result.Paths[i][j].account) + " &rarr; ";
						}
					}
					listItem += (clickableAccountSpan(result.Destination) + "</li>");
					output += listItem;
				}
			} else {
				output += ("<li>"+clickableAccountSpan(result.Account)+ " &rarr; "+clickableAccountSpan(result.Destination)+"</li>");
			}
			return output;
		})()+
		"</ul><b>Signing key:</b> <tt>"+result.SigningPubKey+
		"</tt><br/><b>Signature:</b><br/><span class='stringPiece'>"+
			result.TxnSignature.slice(0,70)+"</span><br/><span class='stringPiece'>"+
			result.TxnSignature.slice(70)+
		"</span><br/><b>Hash:</b> <tt>"+result.hash+
		"</tt><br/><b>Ledger:</b> "+result.inLedger;
	return output;
}

/* //deprecated arrow functions
function calculateArrows(d) {
	var rr = Math.ceil(5+nodeRadius(d.target));
	return "url(\#arrow"+Math.min(59,rr)+")";
}

function updateAllArrows() {
	//deprecated. do nothing.
}
*/

function currentCurrencyBalance(accountNode) {
	var output;
	if (currentCurrency == "XRP") {
		output = accountNode.account.Balance;
	} else {
		output = accountNode.balances[currentCurrency];
		if (!output) { output = 0; }
	}
	return output;
}

function addConnections(origin, trustLines) {
	var transactionMode = (mode=="transaction");
	$("#loading").css("display","none");
	//Receive an array of the format:
	//[{"account":"rnziParaNb8nsU4aruQdwYE3j5jUcqjzFm","balance":"0","currency":"BTC","limit":"0","limit_peer":"0.25","quality_in":0,"quality_out":0},
	//{"account":"rU5KBPzSyPycRVW1HdgCKjYpU6W9PKQdE8","balance":"0","currency":"BTC","limit":"0","limit_peer":"10","quality_in":0,"quality_out":0}]
	nodes[nodeMap[origin]].trustLines = trustLines;
	nodes[nodeMap[origin]].balances = getBalances(origin);

	if (origin == focalNode) {
		updateInformation(origin);
	}
	
	if (currentCurrency != "XRP") { // Change the size of the circle, if we needed to wait until now to figure out its balance (i.e. we're looking at a currency other than XRP.)
		svg.select("g#nodeGroup")
			.select("circle#_"+origin)
			.attr("r", nodeRadius(nodes[nodeMap[origin]]) );
		svg.select("g#haloGroup")
			.select("circle#halo_"+origin)
			.attr("r", HALO_MARGIN+nodeRadius(nodes[nodeMap[origin]]) );
	}

	if (degreeMap[origin] < RECURSION_DEPTH || ( degreeMap[origin] == RECURSION_DEPTH) && transactionMode ) {
		if (!transactionMode) {
			expandedNodes[origin] = true;
		} else {
			provisionallyExpandedNodes[origin] = true;
		}
		var newNodes = [];
		var newLinks = [];
		for (var i=0; i<trustLines.length; i++) {
			var linkWasToExisting = false;
			// add trustLines[i]["account"] to the list of nodes, if it's not on it already.
			// add a link from the current node to trustLines[i]["account"], if it's not there already.
			trustLine = trustLines[i];
			account = trustLine["account"];
			// Fetch the node corresponding to the counterparty of this trust line,
			// or if it's not on the list yet, create one and add it to the list.
			if ("undefined" == typeof nodeMap[account]) {
				if (!transactionMode && (parseFloat(trustLine.limit) != 0.0 ||  parseFloat(trustLine.limit_peer) != 0.0) ) {
					nodeMap[account]=nodes.length;
					degreeMap[account] = degreeMap[origin] + 1;
					var angle = Math.random() * 6.283185307179586;
					var radius= Math.random() * 100;
					var node = {
						x:nodes[nodeMap[origin]].x+Math.cos(angle)*radius,
						y:nodes[nodeMap[origin]].y+Math.sin(angle)*radius,
						account: {
							Account:account,
							Balance:"0",
						},
						trustLines: [],
						balances: {}
					}
					newNodes.push(node);
					nodes.push(node);
					//Only add the node if the trust line is non-zero.
					degreeMap[account] = degreeMap[origin] + 1; 
					serverGetInfo(account); //If this node is not on the list yet, we're going to need to get the info and trustLines for it.
					serverGetLines(account);
				}
			} else {
				var node = nodes[nodeMap[account]];
				linkWasToExisting = true;
			}
			// Now, create links to all of the counterparties that have not been expanded (ie., had their links displayed.). If we're in transaction mode, only add links to existing nodes.
			if ( (!transactionMode && !expandedNodes[account]) || (transactionMode && linkWasToExisting && !provisionallyExpandedNodes[account]) )  {
				var link={};
				function goon(link) {
					if (parseFloat(trustLine.limit) != 0.0 && parseFloat(trustLine.limit_peer) != 0.0) {
						link.strength = 0.5;
					} else {
						link.strength = 1;
					}
					link.currency=trustLines[i].currency;
					le_links.push(link);
				}
				if (parseFloat(trustLine.limit) != 0.0) {
					link.source=nodes[nodeMap[ origin ]];
					link.target=node;
					link.value= parseFloat(trustLine.limit);
					goon(link);
				}
				if (parseFloat(trustLine.limit_peer) != 0.0) {
					var link={};
					link.target=nodes[nodeMap[ origin ]];
					link.source=node;
					link.value= parseFloat(trustLine.limit_peer);
					goon(link);
				}
			}
			
			if (linkWasToExisting) {
			//If we're adding a trust line to an already-existing node, check that node again to see if we should put a halo on it.
				svg.select("g#haloGroup").select("circle#halo_"+account)
					.style("stroke", (numberOfUnseenTrustLines(node)>0)?"#aaa":"none" );
			}
		}
	}
	
	reassignColors(origin);
	addNodes(degreeMap[origin]+1);
	

	//should we add a halo to origin?
	svg.select("g#haloGroup").select("circle#halo_"+origin)
		.style("stroke", (numberOfUnseenTrustLines(nodes[nodeMap[origin]])>0)?"#aaa":"none" );
	
}


function serverGetLines(address) {
	if ($.isEmptyObject(nodes[nodeMap[address]].trustLines)) {
		command= '{"command":"account_lines", "ledger_index":"-1", "account":"'+address+'"}';
		server.socket.send(command);
	} else {
		addConnections(address, nodes[nodeMap[address]].trustLines);
	}
}
function serverGetInfo(address) {
	if (nodes[nodeMap[address]] && nodes[nodeMap[address]].account.index) {
		// Don't do anything if we already have information about this account.
		// TODO: Why does this never happen?
	} else {
		command = '{"command":"account_info", "ident":"'+address+'"}'; 
		server.socket.send(command);
		
		countClause = nodes[nodeMap[address]].transactions ? '' : '"count":true, ';
		command = '{"command":"account_tx", "descending":true, '+countClause+'"account":"'+address+'", "limit":'+TRANSACTION_PAGE_LENGTH+', "ledger_index_min":-1, "ledger_index_max":-1}'; 
		server.socket.send(command);
		
	}
}

var svg = d3.select("#visualization")
	.append("svg:svg")
	.attr("width", w)
	.attr("height", h).attr("pointer-events", "all")
	.style("background-color", "#fff").on("click",function(){
		if($('.sbOptions').css("display") == "block") {
			$('.sbToggle').trigger('click');
		}
		if($('#otherCurrency').css("display") == "block") {
			$('#otherCurrency').trigger('blur');
		}
	})
	.style("float","left").style("border", "1px solid #c8c8c8")
	.style("margin-right","10").call(d3.behavior.zoom({
        dblclick: false,
        wheel: false
    }).on("zoom", redraw)).on("mousewheel.zoom",null).on("dblclick.zoom",null);

var zoomLevel = 1;
var translationX = 0;
var translationY = 0;
/*TODO: Fix this bug in Firefox, where the graph pans strangely when you scroll the mouse wheel. (It should do nothing.)*/
var lastD3ZoomEvent = {scale:1, translate:[0,0]};
var panOffset = [0,0];
function redraw() {
	var translation = d3.event.translate;
	if (d3.event.scale == lastD3ZoomEvent.scale) {
		translationX = translation[0] - panOffset[0];
		translationY = translation[1] - panOffset[1];
		panAndZoom();
	} else {
		panOffset = [panOffset[0] + (d3.event.translate[0] - lastD3ZoomEvent.translate[0]), (panOffset[1] + d3.event.translate[1] - lastD3ZoomEvent.translate[1])];
	}
	lastD3ZoomEvent = jQuery.extend(true, {}, d3.event);
}	


function zoomOut() {
	if (zoomLevel >= 1) {
		$("#zoomInButton").removeAttr("disabled");
	}

	translationX += (w/8 * zoomLevel);
	translationY += (hh/8 * zoomLevel);
	panOffset[0] -= (w/8 * zoomLevel);
	panOffset[1] -= (hh/8 * zoomLevel);
	zoomLevel *= 0.75;
	panAndZoom();
}

function zoomIn() {

	zoomLevel /= 0.75;
	if (zoomLevel >= 1) {
		zoomLevel = 1;
		$("#zoomInButton").attr("disabled","disabled");
	}
	translationX -= (w/8 * zoomLevel);
	translationY -= (hh/8 * zoomLevel);
	panOffset[0] += (w/8 * zoomLevel);
	panOffset[1] += (hh/8 * zoomLevel);
	panAndZoom();
}

function panAndZoom() {
	linkGroup.attr     ("transform","translate(" + [translationX,translationY] + "),scale("+zoomLevel+")");
	nodeGroup.attr     ("transform","translate(" + [translationX,translationY] + "),scale("+zoomLevel+")");
	haloGroup.attr     ("transform","translate(" + [translationX,translationY] + "),scale("+zoomLevel+")");
	arrowheadGroup.attr("transform","translate(" + [translationX,translationY] + "),scale("+zoomLevel+")");
}

var defs = svg.append("defs");

function defineRadialGradient(name, innerColor, outerColor) {
	var radGrad = defs.append("radialGradient")
		.attr("id", name)
		.attr("fx", "50%")
		.attr("fy", "50%")
		.attr("r", "100%")
		.attr("spreadMethod", "pad");
	radGrad.append("stop")
		.attr("offset","0%")
		.attr("stop-color",innerColor)
		.attr("stop-opacity","1");
	radGrad.append("stop")
		.attr("offset","100%")
		.attr("stop-color",outerColor)
		.attr("stop-opacity","1");
}

for (var cur in COLOR_TABLE) {	
	var shades = COLOR_TABLE[cur];
	for (var i=0; i<shades.length; i++) {
		defineRadialGradient("gradient"+cur+i, shades[i][0], shades[i][1]);
	}
}

function defineFilter(name, red, green, blue) {
	var filter = defs.append("filter").attr("id",name).attr("x","-200%").attr("y","-200%").attr("width","800%").attr("height","800%");
	var fct = filter.append("feComponentTransfer").attr("in","SourceAlpha");
	fct.append("feFuncR").attr("type","discrete").attr("tableValues",red+" 1");
	fct.append("feFuncG").attr("type","discrete").attr("tableValues",green+" 1");
	fct.append("feFuncB").attr("type","discrete").attr("tableValues",blue+" 1");
	filter.append("feGaussianBlur").attr("stdDeviation","20");
	filter.append("feOffset").attr("dx","0").attr("dy","0").attr("result","shadow");
	filter.append("feComposite").attr("in","SourceGraphic").attr("in2","shadow").attr("operator","over");
}



for (cur in HIGH_SATURATION_COLORS) {
	var red = HEX_TO_PERCENT[HIGH_SATURATION_COLORS[cur].charAt(1)];
	var green = HEX_TO_PERCENT[HIGH_SATURATION_COLORS[cur].charAt(2)];
	var blue = HEX_TO_PERCENT[HIGH_SATURATION_COLORS[cur].charAt(3)];
	defineFilter("shine"+cur, red, green, blue);
}



var haloGroup = svg.append("g").attr("id","haloGroup");
var linkGroup = svg.append("g").attr("id","linkGroup");
var arrowheadGroup = svg.append("g").attr("id","arrowheadGroup");
var nodeGroup = svg.append("g").attr("id","nodeGroup");

function nodeRadius(accountNode) {
	var bal = currentCurrencyBalance(accountNode);
	if (currentCurrency != "XRP") {
		bal = bal * 1000000000;
	} 
	return 14+Math.pow(Math.log(Math.abs(bal)+1),3) / 2000;
}

var force = d3.layout.force()
	.size([w, 710])
	.linkDistance(80)
	.linkStrength(function(d) {
		if (currentCurrency == "XRP" || currentCurrency == d.currency) {
			return d.strength * 0.25;
		} else {
			return 0;
		}
	}).friction(0.5)
	.charge(-1500).nodes([]).links([]).start();

	



function expandNode(address) {
	var nutl = numberOfUnseenTrustLines(nodes[nodeMap[address]]);
	if (nutl<360 || confirm('This node has '+nutl+' unseen trust lines. Expanding it may slow down your browser. Are you sure?')) { 
		changingFocus = true;
		window.location.hash = address;
		changeMode("individual");
		lastFocalNode = focalNode;
		focalNode = address;
		if ("undefined" == typeof nodeMap[address]) {
			refocus(address, false);
		} else {
			degreeMap = {};
			degreeMap[address] = 0;
			reassignColors(address);
			colorRogueNodes();
			if (expandedNodes[address]) {} else {
				serverGetLines(address);
			}
			updateInformation(address);
		}
	}
}


function borderColor(cur, colorDegree) {
	if (colorDegree == 0) {
		return "#fc0"; //It actually doesn't use the border color for the focal node.
	} else {
		return COLOR_TABLE[cur][colorDegree-1][1]; //Use the rim color of the next darkest degree.
	}
}


function findCur(d) {
	var cur = currentCurrency;
	if(cur != "XRP") {
		if(!d.balances[cur]){cur="__Z";}
		else if(d.balances[cur]<0){cur="__N";}
		else if(!COLOR_TABLE.hasOwnProperty(cur)) {cur = "___";}
	}
	return cur;
}

function lightenNodeFunction(colorDegree) {
	return function(d) {
		var cur = findCur(d);
		d3.select(d3.event.target).style("fill", "url(#gradient"+cur+(colorDegree+1)+")").style("stroke-width", 2).style("stroke", "#fc0" );
	}
}
function darkenNodeFunction(colorDegree) {
	return function(d) {
		var cur = findCur(d);
		d3.select(d3.event.target).style("fill", "url(#gradient"+cur+(colorDegree)+")").style("stroke-width", (colorDegree==0?5:0.5)).style("stroke", function(d){var cur = findCur(d); return borderColor(cur,colorDegree);} );
	}
}
function lightenAddress(address) {
	if (typeof degreeMap[address] != "undefined") {
		var colorDegree = Math.min(degreeMap[address], 3);
		var cur = findCur(force.nodes()[nodeMap[address]]);
		nodeGroup.select("#_"+address).style("fill", "url(#gradient"+cur+(colorDegree+1)+")").style("stroke-width", 2).style("stroke", "#fc0" );
	}
}
function darkenAddress(address) {
	if (typeof degreeMap[address] != "undefined") {
		var colorDegree = Math.min(degreeMap[address], 3);
		var cur = findCur(force.nodes()[nodeMap[address]]);
		nodeGroup.select("#_"+address).style("fill", "url(#gradient"+cur+(colorDegree)+")").style("stroke-width", (colorDegree==0?5:0.5)).style("stroke", function(d){var cur = findCur(d); return borderColor(cur,colorDegree);} );
	}
}


function numberOfUnseenTrustLines(aNode) {
	var output = 0;
	var trustLines = aNode.trustLines;
	for (var i=0; i<trustLines.length; i++) {
		if ((trustLines[i].limit!=0 || trustLines[i].limit_peer!=0) && isLineInvisible(aNode.account.Account, trustLines[i].account)) {
			output++;
		}
	}
	return output;
}

function isLineInvisible(source, target) {
	for (var j=0; j<le_links.length; j++) {
		if ((le_links[j].source.account.Account==source && le_links[j].target.account.Account==target) ||
			(le_links[j].source.account.Account==target && le_links[j].target.account.Account==source)  ) {
			return false;
		}
	}
	return true;
}


function colorNodes(nodeSelection, colorDegree) {
	nodeSelection.style("fill", function(d) { 
			var cur = findCur(d);
			return ("url(#gradient"+cur+colorDegree+")");
		})
		.style("stroke", function(d){var cur = findCur(d); return borderColor(cur,colorDegree);} )
		.style("stroke-width", 0.5 )
		.on("mouseover", lightenNodeFunction(colorDegree))
		.on("mouseout", darkenNodeFunction(colorDegree));
	if (colorDegree == 0) {
		nodeSelection.style("stroke-width", 5);
	}
}
//function(d){ if (numberOfUnseenTrustLines(d) > 0){return 5;} else{return 0.5;}}

function reassignColors(address) {
	var colorDegree = Math.min(degreeMap[address], 3);
	colorNodes(svg.select("g#nodeGroup").select("circle#_"+address), colorDegree)
	
	function goon(counterparty) { // ...then reassign the colors of each counterparty too,
		//only if the new degree is lower than the previous one (or the degree is as yet unknown)
		if (typeof degreeMap[counterparty] == "undefined" || degreeMap[counterparty] > degreeMap[address]+1) {
			degreeMap[counterparty] = degreeMap[address]+1;
			reassignColors(counterparty);
		}
	}
	for (var i=0; i<le_links.length; i++) {
		var link = le_links[i];
		if (link.source.account.Account == address) { // If this address is party to the link...
			goon(link.target.account.Account);
		} else if (link.target.account.Account == address) {
			goon(link.source.account.Account);
		}
	}
}

function colorRogueNodes() {
	for (var address in nodeMap) {
		if (typeof degreeMap[address] == "undefined") {
			degreeMap[address] = Infinity;
			colorNodes(svg.select("g#nodeGroup").select("circle#_"+address), 3);
		}
	}	
}





function lineLength(lineElement) {
	return Math.sqrt(Math.pow(lineElement.attr("x1")-lineElement.attr("x2"),2) + Math.pow(lineElement.attr("y1")-lineElement.attr("y2"),2));
}

function shine(onOrOff, address, cur) {
	$("#_"+address).attr("filter",(onOrOff ? "url(#shine"+cur+")" : "none"));
	/*
	if (onOrOff) {
		$("#_"+address).css("filter","drop-shadow(0 0 10px #ff0)");
	} else {
		//do nothing
	}*/
}



var animatorLinks = [];



function animateLink(onOrOff, speed, from, to, cur, callback) {
	if (typeof nodeMap[from] == "undefined" || typeof nodeMap[to] == "undefined") {
		setTimeout(callback, 10.0/speed);
	} else {
		var animator = $("#" + from + "_" + to + "_" + cur);
		if (animator.length == 0) {
			/*console.log(le_links[0]);
			console.log(from);
			console.log(to);
			console.log(nodes[nodeMap[from]]);
			console.log(nodes[nodeMap[to]]);*/
			animatorLinks.push({source:nodes[nodeMap[from]], target:nodes[nodeMap[to]], value:100, currency:currency, strength:0});
			var alink = svg.select("g#linkGroup").selectAll("line.animator").data(animatorLinks)
				.enter().append("svg:line")
				.attr("x1", function(d){ return d.source.x; })
				.attr("y1", function(d){ return d.source.y; })
				.attr("x2", function(d){ return d.target.x; })
				.attr("y2", function(d){ return d.target.y; })
				.attr("class", "animator")
				.attr("id", from + "_" + to + "_" + cur )
				.style("stroke",function(d){ return HIGH_SATURATION_COLORS[cur];} )
				.style("z-index","2")
				.style("stroke-dasharray","0,999999")
				//.style("display","none")
				.attr("stroke-width", 10);
			animator = $("#" + from + "_" + to + "_" + cur);
		}

		animator.css("display","inherit");
		var pct = 1;
		var interval = setInterval( function(){
			var len = lineLength(animator) * (1-pct);
			if (onOrOff == true) { //If we're turning it on
				animator.css("stroke-dasharray",len+", 999999");
			} else { //If we're turning it off
				animator.css("stroke-dasharray","0, "+len+", 999999");
			}
			pct -= speed;
			if (pct <= 0) {
				if (onOrOff == true) {
					animator.css("stroke-dasharray","");
				} else {
					animator.css("display","none");
				}
				//console.log('done with link');
				clearInterval(interval);
				callback();
			}
		}, 10 );
	}
}


function animateTransaction(tx) {
	var cur;

	
	var initialCur;
	if (tx.SendMax && tx.SendMax.currency) {
		initialCur = tx.SendMax.currency;
		if(!HIGH_SATURATION_COLORS.hasOwnProperty(initialCur)) {initialCur = "___";}
	} else {
		initialCur = "XRP";
	}	
	shine(true, tx.Account, initialCur);
	
	if (tx.Amount.currency) {
		finalCur = tx.Amount.currency;
		if(!HIGH_SATURATION_COLORS.hasOwnProperty(finalCur)) {finalCur = "___";}
	} else {
		finalCur = "XRP";
	}	
	
	var finalCur;
	if (tx.Amount.currency) {
		finalCur = tx.Amount.currency;
		if(!HIGH_SATURATION_COLORS.hasOwnProperty(finalCur)) {finalCur = "___";}
	} else {
		finalCur = "XRP";
	}
	
	var pathList;
	if (tx.Paths) {
		pathList = [];
		for (var i=0; i<tx.Paths.length; i++) {
			//console.log(i);
			var thisOldPath = tx.Paths[i];
			//console.log("OLD PATH:", thisOldPath);
			var thisPath = [];
			for (var j=0; j<thisOldPath.length; j++) {
				if (thisOldPath[j].account) {
					thisPath.push(thisOldPath[j]);
				}
			}
			//console.log("NEW PATH:", thisPath);
			pathList.push(thisPath);
		}
		for (var i=0; i<pathList.length; i++) {
			animatePath(true, i);
		}
	} else {
		pathList = [[]];
		animatePath(true, 0);
	}
	
	function animatePath(onOrOff, i) {
		if (i==pathList.length) {
			console.log("Done with every path!");
		} else {
			var path = pathList[i];
			var lastNode = tx.Account;
			var nextNode;
			var speed = 0.01 * (path.length + 1);
			function animatePathLink(j) {
				if (j==path.length) {
					animateLink(onOrOff, speed, lastNode, tx.Destination, finalCur, function(){shine(onOrOff, tx.Destination, finalCur); if(onOrOff) {shine(false, tx.Account); animatePath(false, i);} });
				} else {
					nextNode = path[j].account;
					/*
					if (!nextNode) {
						j++;
						console.log(j, path);
						nextNode = path[j].account;
					}
					if (!nextNode) {
						j++;
						console.log(j, path);
						nextNode = path[j].account;
					}
					console.log("NEXT:", i, j, nextNode);*/
					if (path[j].currency) {
						cur = path[j].currency;
						if(!HIGH_SATURATION_COLORS.hasOwnProperty(cur)) {cur = "___";}
					} else {
						cur = "XRP";
					}
					
					animateLink(onOrOff, speed, lastNode, nextNode, cur, function(){shine(onOrOff, nextNode, cur); animatePathLink(j+1)});
					lastNode = nextNode;
				}
			}
			animatePathLink(0);
		}
	}

	
	
}





var lastNodeTouched = "";

function stopExpandResume(d) {
	force.stop();
	expandNode(d.account.Account);
	setTimeout(force.resume,500);
}

function addNodes(degree) {

	force.nodes(nodes).links(le_links);
	var timer;
	var colorDegree = Math.min(degree, 3);
	var node = svg.select("g#nodeGroup").selectAll("circle.node").data(nodes)
		.enter().append("svg:circle")
		.attr("class", "node")
		.attr("id", function(d) { return "_"+d.account.Account;})
		.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; })
		.attr("r", nodeRadius )
		.attr("title", function(d) { return d.account.Account; })
		.style("cursor", "pointer")
		.on("touchstart", function() {  } )
		.on("touchmove", function(d) { lastNodeTouched=d.account.Account; } )
		.on("touchend", function(d) { if (lastNodeTouched != d.account.Account) {stopExpandResume(d); lastNodeTouched=d.account.Account;} else {lastNodeTouched="";} } )
		.on("click", stopExpandResume );
	colorNodes(node, colorDegree);
	node.append("svg:title").text( function(d) { return d.account.Account;} );
	node.call(force.drag);
	
	

	var link = svg.select("g#linkGroup").selectAll("line.static").data(force.links())
		.enter().append("svg:line")
		.attr("class","static")
		.style("stroke","#000")
		.style("opacity","0.2")
		.attr("stroke-width", linkOrNot);


	function arrowheadPath(radius, theta) {
		var rCosTheta = radius*Math.cos(theta);
		var rSinTheta = radius*Math.sin(theta);
		return "M 0 0 L "+
			rCosTheta+" "+rSinTheta+" L "+
			(rCosTheta+rSinTheta*Math.sqrt(3))+" 0 L "+
			rCosTheta+" "+(-rSinTheta)+" z";
	}
	var arrowhead = svg.select("g#arrowheadGroup").selectAll("path.arrowhead").data(force.links())
		.enter().append("svg:path")
		.attr("class", "arrowhead");


	arrowhead = setArrowheads(arrowhead);
	
	function euclidean(pointA, pointB) {
		return Math.sqrt(Math.pow(pointA.x-pointB.x,2)
			+Math.pow(pointA.y-pointB.y,2));
	}
	
	function projection(distance, origin, towards) {
		var farDistance = euclidean(origin, towards);
		var scalar = distance/farDistance;
		var xOutput = origin.x + (towards.x-origin.x)*scalar;
		var yOutput = origin.y + (towards.y-origin.y)*scalar;
		return {x:xOutput, y:yOutput};
	}
	
	function angle(pointA, pointB) {
		return 180/Math.PI * Math.atan2(pointB.y-pointA.y, pointB.x-pointA.x);
	}
	
	function thetaValue(value) {
		return value/(1+value) * 1.04719755 // max = 60 degrees in radians
	}
	
	function setArrowheads(selection) {
		return selection
			.attr("transform", function(d) {
				var position = d.source;
				return "translate("+position.x+","+position.y+"), rotate("+angle(d.source,d.target)+",0,0)";
			})
			.attr("d", function(d) {return arrowheadPath(parseFloat($("#_"+d.source.account.Account).attr("r")), thetaValue(d.value)); } )
			.style("fill", function(d){ return (isLinkVisible(d) ? "#000" : "none"); } );

	}

	
	var halo = svg.select("g#haloGroup").selectAll("circle.halo").data(nodes)
		.enter().append("svg:circle")
		.attr("class", "halo")
		.attr("id", function(d) { return "halo_"+d.account.Account;})
		.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; })
		.attr("r", function(d){ return HALO_MARGIN+nodeRadius(d);} )
		.style("fill", "none" )
		.style("stroke", "none" )
		.style("stroke-width", 1 );
		
	force.start();
  


	

	force.on("tick", function(e) {
		var node = svg.selectAll("circle.node");
		var halo = svg.selectAll("circle.halo");
		var arrowhead = svg.selectAll("path.arrowhead");
		var link = svg.selectAll("line");
		node.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; });
		link.attr("x1", function(d) {return d.source.x;})
			.attr("y1", function(d) {return d.source.y;})
			.attr("x2", function(d) {return d.target.x;})
			.attr("y2", function(d) {return d.target.y;});
		halo.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; });
		setArrowheads(arrowhead);
	});
}

function refocus(focus, erase) {
	changingFocus = true;
	if (erase) {
		eraseGraph();
	}
	window.location.hash = focus;
	lastFocalNode = focalNode;
	focalNode = focus;
	nodeMap[focalNode] = nodes.length;
	nodes.push({x:0.5*w, y:hh/2, account:{Account:focalNode, Balance:0}, trustLines:[], balances:{} });
	degreeMap = {};
	degreeMap[focalNode] = 0;
	serverGetLines(focalNode);
	addNodes(0);
	reassignColors(focalNode);
	colorRogueNodes();
	serverGetInfo(focalNode);
	updateInformation(focus);
}



function commas(number) {
    var parts = number.toString().split(".");
    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return parts.join(".");
}

function abbreviate(address) {
	return address.slice(0,25)+"...";
}

function magnitude(factor) {
	if (factor <= 1000000000000000) {
		return {
			1: '',
			1000: 'K',
			1000000: 'M',
			1000000000: 'B',
			1000000000000: 'T',
			1000000000000000: 'Q'}[factor];
	} else {
		return "&times;10<sup>"+Math.round(Math.log(factor) / Math.LN10)+"</sup>";
	}
}

function roundNumber(number) {
	if (Math.abs(number) < 10000.00) {
		return commas(Math.round(number*100)/100);
	} else {
		var logarithm = Math.floor(Math.log(Math.abs(number)) / Math.LN10);
		var factor = Math.pow(1000,Math.floor((logarithm - 4)/3));
		var rounded = Math.round(number/factor);
		return commas(rounded) + magnitude(factor);
	}
}

function updateInformation(address) {
	$('#focus').val(address);
	$('#focalAddress').text(address);
	


	var currencies = [];
	var balances = getBalances(address);
	for (var cur in balances) {
		currencies.push(cur);
	}
	currencies.sort(function(a,b){return (Math.abs(balances[b])-Math.abs(balances[a]))});
	
	var trustLines = nodes[nodeMap[address]].trustLines;
	if (!trustLines) {
		trustLines = [];
	}

	$('#balanceTable').text("");
	$('#balanceTable').append(
		'<tr class="toprow">'+
			'<td class="circlecell"><svg width="22" height="22">'+
				'<circle cx="11" cy="11" r="11" style="fill:'+COLOR_TABLE['XRP'][0][1]+';"></circle>'+
			'</svg></td>'+
			'<td class="light small mediumgray" style="width:35px;">XRP</td>'+
			'<td class="bold amount" id="xrpBalance">'+commas(nodes[nodeMap[address]].account.Balance/1000000)+'</td>'+
			'<td class="light expander">&nbsp;</td>'+
		'</tr>');
	
	for (var i=0; i<currencies.length; i++) {
		var cur = currencies[i];
		var trustLinesForCur = [];
		for (var j=0; j<trustLines.length; j++) {
			var trustLine = trustLines[j];
			if (trustLine.currency == cur) {
				trustLinesForCur.push(trustLine);
			}
		}
		trustLinesForCur.sort(function(a,b){return Math.abs(b.balance)-Math.abs(a.balance);});
		$('#balanceTable').append(
			'<tr style="cursor:'+(trustLinesForCur.length ? 'pointer' : 'auto')+'" sublistid="'+cur+
					'" numberofsubrows="'+trustLinesForCur.length+'" '+
					'onclick="'+(trustLinesForCur.length ? 'toggleExpansion(this)' : '')+'">'+
				'<td class="circlecell"><svg width="22" height="22">'+
					'<circle cx="11" cy="11" r="11" style="fill:'+COLOR_TABLE[(COLOR_TABLE.hasOwnProperty(cur)?cur:'___')][0][1]+';"></circle>'+
				'</svg></td>'+
				'<td class="light small mediumgray">'+cur+'</td>'+
				'<td class="bold amount">'+commas(balances[cur])+'</td>'+
				'<td class="light expander">'+(trustLinesForCur.length ? '<span id="'+cur+'Expander">+</span></td>' : '&nbsp;')+
			'</tr>');
			
		if (trustLinesForCur.length) {
			$('#balanceTable').append(
				'<tr class="innertablecontainer" id="'+cur+'">'+
				'<td colspan=4>'+
				'<div id="'+cur+'Inner">'+
				'<table class="innertable" style="table-layout:fixed;" id="'+cur+'InnerTable">'+
				'</table></div></td></tr>');
			$('#'+cur+'InnerTable').append(
				'<tr>'+
					'<th class="light midsize mediumgray" style="width:50%;">å°å</th>'+
					'<td class="light midsize mediumgray" style="width:16%;">æå°</td>'+
					'<td class="light midsize mediumgray center" style="width:16%">å¹³è¡¡</td>'+
					'<td class="light midsize mediumgray right" style="width:16%;">æå¤§</td>'+
				'</tr>');
			for (var j=0; j<trustLinesForCur.length; j++) {
				var tl = trustLinesForCur[j];
				$('#'+cur+'InnerTable').append(
					'<tr>'+
						'<th class="light address"><span style="cursor:pointer;overflow:hidden; text-overflow:ellipsis; display:block;" '+
							'onmouseover="lightenAddress(\''+tl.account+'\');"'+
							'onmouseout="darkenAddress(\''+tl.account+'\');"'+
							'onclick="expandNode(\''+tl.account+'\');">'+
							tl.account+'</span></th>'+
						'<td class="light '+(tl.limit_peer>0 ? 'negative ' : '')+'amount"><span title="'+commas(-1*tl.limit_peer)+'">'+roundNumber(-1*tl.limit_peer)+'</span></td>'+
						'<td style="width:37px;" class="bold '+(tl.balance<0 ? 'negative ' : '')+'amount center"><span title="'+commas(tl.balance)+'">'+roundNumber(tl.balance)+'</span></td>'+
						'<td style="width:37px;" class="light '+(tl.limit<0 ? 'negative ' : '')+'amount right"><span title="'+commas(tl.limit)+'">'+roundNumber(tl.limit)+'</span></td>'+
					'</tr>');
			}		
		}
	}
	updateTransactions(address);
}

var txAltText = {
	"send"       :"Sent payment to...",
	"receive"    :"Received payment from...",
	"intermediate":"Intermediated payment of...",
	"trustout"   :"Sent trust to...",
	"trustin"    :"Received trust from...",
	"offerout"   :"Made offer to give...",
	"offerin"    :"Accepted offer",
	"canceloffer":"Canceled offer"};

function showTransactionWithHash(hash) {
	changingFocus = true;
	window.location.hash = hash;
	changeMode("transaction",transactionMap[hash]);
}
var transactionMap = {};
	
function updateTransactions(address, appending) {
	if (!appending) {
		$('#transactionTable').text("");
	}
	$("#transactionThrobber").remove();
	if (nodes[nodeMap[address]].transactions) {
		for (var i=$('#transactionTable tr').length; i<nodes[nodeMap[address]].transactions.length; i++) {
			var tx = nodes[nodeMap[address]].transactions[i].tx;
			var transactionType;
			var counterparty = "";
			var amount = null;
			var currency = null;
			var secondAmount = null;
			var secondCurrency = null;

			if (tx.TransactionType == "Payment") {
				amount = tx.Amount;
				if (tx.Account == address) {
					transactionType = "send";
					counterparty = tx.Destination;
				}
				else if (tx.Destination == address) {
					transactionType = "receive";
					counterparty = tx.Account;
				} else {
					transactionType = "intermediate";
				}
			} else if (tx.TransactionType == "TrustSet") {
				amount = tx.LimitAmount;
				if (tx.Account == address) {
					transactionType = "trustout";
					counterparty = tx.LimitAmount.issuer;
				}
				else if (tx.LimitAmount.issuer == address) {
					transactionType = "trustin";
					counterparty = tx.Account;
				} else {
					console.log("Could not interpret transaction TrustSet!");
					continue;
				}
			} else if (tx.TransactionType == "OfferCreate") {
				transactionType = "offerout";
				amount = tx.TakerGets;
				secondAmount = tx.TakerPays;
			} else if (tx.TransactionType == "OfferCancel") {
				transactionType = "canceloffer";
			} else {console.log("Could not interpret transaction: "+tx.transactionType);}

			if (amount) {
				if (amount.currency) {
					currency = amount.currency;
					amount = amount.value;
				} else {
					currency = "XRP";
					amount = amount/1000000;
				}
			}
			
			if (secondAmount) {
				if (secondAmount.currency) {
					secondCurrency = secondAmount.currency;
					secondAmount = secondAmount.value;
				} else {
					secondCurrency = "XRP";
					secondAmount = secondAmount/1000000;
				}
			}
			
			
			transactionMap[tx.hash] = tx;


			$('#transactionTable').append(
				'<tr>'+
					'<td style="width:46px"><div '+(transactionType=='send'||transactionType=='receive'||transactionType=='intermediate'?'onclick="showTransactionWithHash(\''+tx.hash+'\');"':'style="cursor:default;"')+' class="'+transactionType+' icon" title="'+txAltText[transactionType]+'">&nbsp;</div></td>'+
					'<td style="width:374px"'+(counterparty==""?' colspan="1"':'')+'><span style="float:left">'+(amount?('<span class="bold amount small" >'+commas(amount)+'</span> <span class="light small darkgray" style="margin-right:5px">'+currency+'</span>'+
					(secondAmount?' <i class="light small darkgray" style="margin-right:5px">for</i> <span class="bold amount small">'+commas(secondAmount)+'</span> <span class="light small darkgray" style="margin-right:5px">'+secondCurrency+'</span>':'')):'')+
					agoDate(tx.date)+'</span>'+
					(counterparty!=""?'<span style="display:block; margin-top:3px; overflow:hidden; text-overflow:ellipsis;" class="light address right"><span style="cursor:pointer;" '+
							'onmouseover="lightenAddress(\''+counterparty+'\');"'+
							'onmouseout="darkenAddress(\''+counterparty+'\');"'+
							'onclick="expandNode(\''+counterparty+'\');">'+
							counterparty+'</span></span></td>' : '')+
					'<td class="marginalcell"/>'+
				'</tr>');

		}
		
		
		if (nodes[nodeMap[address]].transactions.length < nodes[nodeMap[address]].transactionCount) { //Are there more?
			$('#transactionTable').append('<tr id="transactionThrobber"><td colspan=3 style="text-align:center; padding:10px"><img src="throbber4.gif" width=30 height=30 /></td></tr>');
			$('#transactionThrobber').bind('inview', function (event, visible) {
				if (visible == true) {
					getNextTransactionPage();
				}
			});
		}

	}
}

var TRANSACTION_PAGE_LENGTH = 13;

function getNextTransactionPage() {
	//request transactions for the current account, with offset = nodes[nodeMap[address]].transactions.length
	command = '{"command":"account_tx", "descending":true, "account":"'+focalNode+'", "limit":'+TRANSACTION_PAGE_LENGTH+', "offset":'+nodes[nodeMap[focalNode]].transactions.length+', "ledger_index_min":-1, "ledger_index_max":-1}'; 
	server.socket.send(command);
	
	
	//when the answer comes back, see if it's new information.
	//if so, update WITH THE NEW INFO ONLY (i.e., don't clear the whole table, only do
	//$("#transactionThrobber").remove();
	//and add the new stuff.
}

function agoDate(secondsSince2000) {
	var currentTime = new Date().getTime() / 1000 - 946684800;
	var secondsAgo = currentTime-parseInt(secondsSince2000);
	var number;
	var unit;
	if (secondsAgo < 1) {
		number = 0;
		unit = "å½å";
	} else if (secondsAgo < 60) {
		number = Math.floor(secondsAgo);
		unit = "ç§";
	} else if (secondsAgo < 3600) {
		number = Math.floor(secondsAgo/60);
		unit = "åé";
	} else if (secondsAgo < 86400) {
		number = Math.floor(secondsAgo/3600);
		unit = "å°æ¶";
	} else if (secondsAgo < 604800) {
		number = Math.floor(secondsAgo/86400);
		unit = "å¤©";
	} else if (secondsAgo < 2629746) {
		number = Math.floor(secondsAgo/604800);
		unit = "å¨";
	} else if (secondsAgo < 31556952) {
		number = Math.floor(secondsAgo/2629746);
		unit = "æ";
	} else {
		number = Math.floor(secondsAgo/31556952);
		unit = "å¹´";
	}
	if (number != 1) {
		unit += ""
	}
	if (number == 0) {
		number = "";
	}
	
	var d = new Date(0);
	d.setUTCSeconds(secondsSince2000+946684800);
	return '<span style="margin-right:5px" class="light small mediumgray date" title="'+d.toUTCString()+'">'+number+" "+unit+'å</span>';
}

function absoluteDate(secondsSince2000) {
	var d = new Date(0);
	d.setUTCSeconds(secondsSince2000+946684800);
	return '<span class="light small mediumgray date" title="'+d.getHours()+':'+(d.getMinutes()<10 ? '0'+d.getMinutes() : d.getMinutes())+':'+(d.getSeconds()<10 ? '0'+d.getSeconds() : d.getSeconds())+'">'+d.getDate()+' '+['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][d.getMonth()]+' '+d.getFullYear()+'</span>';
}
function absoluteTime(secondsSince2000) {
	var d = new Date(0);
	d.setUTCSeconds(secondsSince2000+946684800);
	return '<span class="light small mediumgray date" title="'+d.getDate()+' '+['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][d.getMonth()]+' '+d.getFullYear()+'">'+d.getHours()+':'+(d.getMinutes()<10 ? '0'+d.getMinutes() : d.getMinutes())+':'+(d.getSeconds()<10 ? '0'+d.getSeconds() : d.getSeconds())+'</span>';
}




function getBalances(address) {
	var balances = {};
	if (nodes[nodeMap[address]].trustLines) {
		for (var i=0; i<nodes[nodeMap[address]].trustLines.length; i++) {
			var trustLine = nodes[nodeMap[address]].trustLines[i];
			if (balances[trustLine.currency]) {
				balances[trustLine.currency] += parseFloat(trustLine.balance);
			} else {
				balances[trustLine.currency] = parseFloat(trustLine.balance);
			}
		}
	}
	return balances;
}

function linkOrNot(d) {
	if(currentCurrency=="XRP" || currentCurrency==d.currency) {
		var o = 5*Math.pow(Math.log(1+d.value),0.3333);;
		return o;
	} 
	else{return 0;}
}

function isLinkVisible(d) {
	return currentCurrency=="XRP" || currentCurrency==d.currency
}

function changeCurrency(newCurrency) {
	var isOther = (newCurrency == '___');
	if (isOther && $('#otherCurrency').css('font-style')!='italic') {
		newCurrency = $('#otherCurrency').attr('value');
	}
	if (newCurrency == "___") {
		$("#otherCurrency").css("display","block");
	} else {
		if (isOther) {
			$("#otherCurrency").css("display","block");
		} else {
			$("#otherCurrency").css("display","none");
		}
		currentCurrency = newCurrency;
		degreeMap = {};
		degreeMap[focalNode] = 0;
		reassignColors(focalNode);
		colorRogueNodes();
		updated = svg.select("g#nodeGroup").selectAll("circle.node");
		updated.attr("r", nodeRadius );
		svg.select("g#haloGroup").selectAll("circle.halo").attr("r", function(d){return HALO_MARGIN+nodeRadius(d);} );
		svg.select("g#linkGroup").selectAll("line.static").attr("stroke-width", linkOrNot);
		force.start();
	}
}

function toggleExpansion(row) {
	var cur = row.getAttribute("sublistid");
	var numberOfSubrows = parseInt(row.getAttribute("numberofsubrows"));
	var expander = document.getElementById(cur+"Expander");
	if (expander.innerHTML == "+") {
		$('#'+cur+'Inner').animate({height:(11+(numberOfSubrows+1)*25.5)+'px'});
				$('#'+cur).show()
		expander.innerHTML = "&ndash;";
	} else {
		$('#'+cur+'Inner').animate({height:'0px'}, {complete: function(){$('#'+cur).hide();} });
		expander.innerHTML = "+";
	}
}


function focusOtherCurrency(that) {
	if ($(that).css('font-style')=='italic') {
		$(that).css('font-style','inherit').css('color','inherit').attr('value','');
	}
}

function blurOtherCurrency(that) {
	if ($(that).attr('value')=='' || $(that).css('font-style')=='italic') { 
		$(that).css('font-style','italic').css('color','#999').attr('value','other');
	} else {
		var upper=$(that).attr('value').toUpperCase();
		$(that).attr('value',upper);
		changeCurrency('___');
	}
}

window.onhashchange = function(){
	if (!changingFocus) {
		if (window.location.hash == "" || window.location.hash == "#") {
			refocus(REFERENCE_NODE, true);
		} else if (window.location.hash.charAt(1) == "r") {
			if (nodeMap[window.location.hash.substring(1)]) {
				expandNode(window.location.hash.substring(1));
			} else {
				//the user edited the hash to something invalid, so don't do anything.
			}
		} else if ("0123456789ABCDEF".indexOf(window.location.hash.charAt(1)) != -1) {
			showTransactionWithHash(window.location.hash.substring(1));
		} else {
			//do nothing
		}
	} else {
		//console.log("REDUNDANT!");
	}
	changingFocus = false;
};

</script>


<!-- Initialization functions -->
<script>



	$(function () {$('.scroll-pane').jScrollPane({autoReinitialise: true, hideFocus: true});});
	$(function () {$("#currency").selectbox();});
	$("#focus").keyup(function(event){
		if(event.keyCode == 13){
			$("#searchButton").click();
		}
	});
	$("#otherCurrency").keyup(function(event){
		if(event.keyCode == 13){
			$(this).blur();
		}
	});
	updateInformation(focalNode);
	
</script>



</body>
</html>
